How did you handle inline editing in the table?
	Inline editing in the table was handled through the properties of the Tabulator's editor in the column definition. For example, the column "Title" uses input editor to directly edit it in the cell, the column "Status" by using select editor with list of predefined values. Whenever a cell has been edited, the state triggers a callback called by cellEdited, where I updated the corresponding task in state by finding the edited task in data array and replace it with the updated version. It means that such changes are reflected immediately not only in the UI but in the underlying data as well.

Explain how you fetched and processed the data from the dummy API.
	Data was fetched through the dummy API using the fetch method in a useEffect hook so that it loaded when this component mounted. The data received from the API call in JSON format was manipulated to fetch task details. This fetched data was structured to an array of objects to represent every task with a number of properties such as ID, Title, Status, and Created Date. Error handling used in the form of try catch blocks to log issues or flash fallback messages in the instance of network or API failure. Finally, in state, the processed data were written using React's useState from the component, where such data would be utilized when rendering in the table.



What approach did you use to filter tasks based on status?
	In the implementation of the dropdown to filter tasks by status, a dropdown menu is added for selection between "To Do" and "Done." A function is triggered after each selection; it is filterTasks, which filters the list of tasks in the state by looking at the completed field for each task. The tasks with the value being false are considered "To Do", while the others with a value of true are considered "Done". By default, it displays all tasks if no filter has been applied. Then these filtered tasks are stored in the state called filteredData. It just makes sure that only matching tasks according to the chosen status are presented in the table.

How did you manage the state of tasks when adding or editing them?
	Adding or editing tasks, I used React's useState hook in managing the state. When adding a task, I used a newTask state to store the values temporarily from the form entries. Once the user clicks the "Add Task" button, an addTask function is executed, which creates a new task object with the current values of newTask and assigns it a unique ID. The data state arrays, including all tasks, and filteredData state arrays, which contain filtered tasks, are updated. As a result, the new task added will appear in the table without refreshing the page.
	Using a provided callback called cellEdited for editing tasks. After all, when the editing in a cell is invoked, this callback function executes automatically and updates the involved task in the data array. The setData and setFilteredData functions are consequently invoked to update the information at both the list display level and the filtered level so that any modification involving title or status for that matter will be updated live.


What challenges did you face during development, and how did you overcome them?
	One of the main issues that occurred during development was how to handle the asynchronous data fetching from the API and ensuring that the data was properly rendered in the table. Initially, the issue was with how the data was being updated and displayed in the table after fetching, especially when dealing with the filtering and inline editing functionality. To overcome this, I carefully managed the state using React's useState and ensured that the table re-rendered with the correct data by updating both the data and filteredData states after every change, like adding, deleting, or editing tasks. Another challenge was integrating Tabulator library with React since Tabulator handles the table rendering. I had to ensure that it was called only once after the data is fetched and that the table is updated properly with changes in data. The above was achieved by use of useEffect to initialize tabulator and re-initializing it whenever filteredData had changed.
	Lastly, handling the inline editing and ensuring that the changes occurred immediately in both the state and the table required proper management of the data updates. I used Tabulator's cellEdited callback to update the task details in the state and ensure that the UI stayed in sync with the changes made by the user.